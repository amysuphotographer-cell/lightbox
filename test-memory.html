<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†…å­˜ä¼˜åŒ–æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 40px;
            background: #0a0a1f;
            color: #e5e7eb;
        }
        .test-section {
            background: #1a1a3e;
            border: 1px solid #8b5cf6;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
        }
        h2 {
            color: #8b5cf6;
            margin-top: 0;
        }
        button {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        button:hover {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }
        .result {
            margin-top: 20px;
            padding: 16px;
            background: rgba(139, 92, 246, 0.1);
            border-radius: 8px;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        .success {
            color: #10b981;
        }
        .warning {
            color: #f59e0b;
        }
        .error {
            color: #ef4444;
        }
        .progress {
            margin-top: 10px;
            height: 4px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: #8b5cf6;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª å†…å­˜ä¼˜åŒ–æµ‹è¯•</h1>

    <div class="test-section">
        <h2>æµ‹è¯•1ï¼šDataURL vs Blob URL å†…å­˜å¯¹æ¯”</h2>
        <button onclick="testDataURL()">æµ‹è¯• DataURLï¼ˆæ—§æ–¹å¼ï¼‰</button>
        <button onclick="testBlobURL()">æµ‹è¯• Blob URLï¼ˆæ–°æ–¹å¼ï¼‰</button>
        <button onclick="cleanup()">æ¸…ç†å†…å­˜</button>
        <div id="result1" class="result"></div>
        <div class="progress">
            <div id="progress1" class="progress-bar" style="width: 0%"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>æµ‹è¯•2ï¼šç¼©ç•¥å›¾å°ºå¯¸å¯¹æ¯”</h2>
        <button onclick="testSize800()">800x800 ç¼©ç•¥å›¾</button>
        <button onclick="testSize300()">300x300 ç¼©ç•¥å›¾</button>
        <div id="result2" class="result"></div>
        <div class="progress">
            <div id="progress2" class="progress-bar" style="width: 0%"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>æ€§èƒ½ç›‘æ§</h2>
        <div id="memoryInfo" class="result">
            ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æµ‹è¯•...
        </div>
    </div>

    <script>
        let cache = [];

        // ç”Ÿæˆæµ‹è¯•å›¾ç‰‡
        function generateTestImage(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // ç»˜åˆ¶éšæœºå›¾æ¡ˆï¼ˆæ¨¡æ‹ŸçœŸå®å›¾ç‰‡ï¼‰
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
                ctx.fillRect(Math.random()*width, Math.random()*height, 50, 50);
            }

            return canvas;
        }

        // æµ‹è¯•DataURL
        async function testDataURL() {
            const result = document.getElementById('result1');
            const progress = document.getElementById('progress1');
            result.innerHTML = 'æµ‹è¯•ä¸­...';
            cache = [];

            const startMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const startTime = Date.now();
            const testCount = 50;

            for (let i = 0; i < testCount; i++) {
                const canvas = generateTestImage(800, 800);
                const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                cache.push(dataURL);

                progress.style.width = ((i + 1) / testCount * 100) + '%';
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            const endTime = Date.now();
            const endMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const memUsed = ((endMem - startMem) / 1024 / 1024).toFixed(2);
            const avgSize = (cache.reduce((sum, url) => sum + url.length, 0) / cache.length / 1024).toFixed(2);

            result.innerHTML = `
                <div class="warning">âŒ DataURL æ–¹å¼ï¼ˆæ—§ï¼‰</div>
                ç”Ÿæˆæ•°é‡ï¼š${testCount} å¼ <br>
                è€—æ—¶ï¼š${endTime - startTime}ms<br>
                å†…å­˜å¢é•¿ï¼š<span class="error">${memUsed} MB</span><br>
                å¹³å‡å¤§å°ï¼š<span class="error">${avgSize} KB</span> (Base64ç¼–ç )<br>
                <br>
                <small>* æ³¨æ„ï¼šBase64ç¼–ç ä¼šè®©æ•°æ®è†¨èƒ€33%</small>
            `;
            updateMemoryInfo();
        }

        // æµ‹è¯•Blob URL
        async function testBlobURL() {
            const result = document.getElementById('result1');
            const progress = document.getElementById('progress1');
            result.innerHTML = 'æµ‹è¯•ä¸­...';
            cache = [];

            const startMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const startTime = Date.now();
            const testCount = 50;

            for (let i = 0; i < testCount; i++) {
                const canvas = generateTestImage(800, 800);
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                });
                const blobURL = URL.createObjectURL(blob);
                cache.push(blobURL);

                progress.style.width = ((i + 1) / testCount * 100) + '%';
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            const endTime = Date.now();
            const endMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const memUsed = ((endMem - startMem) / 1024 / 1024).toFixed(2);
            const avgSize = (cache.reduce((sum, url) => sum + url.length, 0) / cache.length).toFixed(0);

            result.innerHTML = `
                <div class="success">âœ… Blob URL æ–¹å¼ï¼ˆæ–°ï¼‰</div>
                ç”Ÿæˆæ•°é‡ï¼š${testCount} å¼ <br>
                è€—æ—¶ï¼š${endTime - startTime}ms<br>
                å†…å­˜å¢é•¿ï¼š<span class="success">${memUsed} MB</span><br>
                URLå¤§å°ï¼š<span class="success">${avgSize} å­—èŠ‚</span> (ä»…å¼•ç”¨)<br>
                <br>
                <small>âœ“ æ— Base64ç¼–ç ï¼ŒèŠ‚çœçº¦33%å†…å­˜</small>
            `;
            updateMemoryInfo();
        }

        // æµ‹è¯•800x800
        async function testSize800() {
            const result = document.getElementById('result2');
            const progress = document.getElementById('progress2');
            result.innerHTML = 'æµ‹è¯•ä¸­...';
            cache = [];

            const startMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const startTime = Date.now();
            const testCount = 50;

            for (let i = 0; i < testCount; i++) {
                const canvas = generateTestImage(800, 800);
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.9);
                });
                cache.push(blob);

                progress.style.width = ((i + 1) / testCount * 100) + '%';
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            const endTime = Date.now();
            const endMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const memUsed = ((endMem - startMem) / 1024 / 1024).toFixed(2);
            const avgBlobSize = (cache.reduce((sum, blob) => sum + blob.size, 0) / cache.length / 1024).toFixed(2);

            result.innerHTML = `
                <div class="warning">âŒ 800x800 ç¼©ç•¥å›¾ï¼ˆæ—§ï¼‰</div>
                ç”Ÿæˆæ•°é‡ï¼š${testCount} å¼ <br>
                è€—æ—¶ï¼š${endTime - startTime}ms<br>
                å†…å­˜å¢é•¿ï¼š<span class="error">${memUsed} MB</span><br>
                å¹³å‡å¤§å°ï¼š<span class="error">${avgBlobSize} KB</span><br>
            `;
            updateMemoryInfo();
        }

        // æµ‹è¯•300x300
        async function testSize300() {
            const result = document.getElementById('result2');
            const progress = document.getElementById('progress2');
            result.innerHTML = 'æµ‹è¯•ä¸­...';
            cache = [];

            const startMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const startTime = Date.now();
            const testCount = 50;

            for (let i = 0; i < testCount; i++) {
                const canvas = generateTestImage(300, 300);
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                });
                cache.push(blob);

                progress.style.width = ((i + 1) / testCount * 100) + '%';
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            const endTime = Date.now();
            const endMem = performance.memory ? performance.memory.usedJSHeapSize : 0;
            const memUsed = ((endMem - startMem) / 1024 / 1024).toFixed(2);
            const avgBlobSize = (cache.reduce((sum, blob) => sum + blob.size, 0) / cache.length / 1024).toFixed(2);

            result.innerHTML = `
                <div class="success">âœ… 300x300 ç¼©ç•¥å›¾ï¼ˆæ–°ï¼‰</div>
                ç”Ÿæˆæ•°é‡ï¼š${testCount} å¼ <br>
                è€—æ—¶ï¼š${endTime - startTime}ms<br>
                å†…å­˜å¢é•¿ï¼š<span class="success">${memUsed} MB</span><br>
                å¹³å‡å¤§å°ï¼š<span class="success">${avgBlobSize} KB</span><br>
                <br>
                <small>âœ“ å°ºå¯¸å‡å°78%ï¼Œå†…å­˜èŠ‚çœæ˜¾è‘—</small>
            `;
            updateMemoryInfo();
        }

        // æ¸…ç†
        function cleanup() {
            cache.forEach(item => {
                if (typeof item === 'string' && item.startsWith('blob:')) {
                    URL.revokeObjectURL(item);
                }
            });
            cache = [];

            document.getElementById('result1').innerHTML = '<span class="success">âœ“ ç¼“å­˜å·²æ¸…ç†</span>';
            document.getElementById('result2').innerHTML = '<span class="success">âœ“ ç¼“å­˜å·²æ¸…ç†</span>';
            document.getElementById('progress1').style.width = '0%';
            document.getElementById('progress2').style.width = '0%';

            // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (window.gc) {
                window.gc();
            }

            setTimeout(updateMemoryInfo, 1000);
        }

        // æ›´æ–°å†…å­˜ä¿¡æ¯
        function updateMemoryInfo() {
            const info = document.getElementById('memoryInfo');

            if (!performance.memory) {
                info.innerHTML = `
                    <div class="warning">âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜ç›‘æ§</div>
                    è¯·åœ¨Chromeä¸­å¯ç”¨ï¼š--enable-precise-memory-info
                `;
                return;
            }

            const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
            const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
            const limit = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2);
            const percent = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit * 100).toFixed(1);

            info.innerHTML = `
                <strong>å½“å‰å†…å­˜ä½¿ç”¨ï¼š</strong><br>
                å·²ä½¿ç”¨ï¼š${used} MB / ${total} MB<br>
                å†…å­˜ä¸Šé™ï¼š${limit} MB<br>
                ä½¿ç”¨ç‡ï¼š${percent}%<br>
                ç¼“å­˜é¡¹æ•°ï¼š${cache.length}<br>
                <br>
                <small>æç¤ºï¼šåœ¨Chromeåœ°å€æ è¾“å…¥ chrome://flagsï¼Œæœç´¢ "precise memory"ï¼Œå¯ç”¨åé‡å¯æµè§ˆå™¨å¯æŸ¥çœ‹å‡†ç¡®å†…å­˜æ•°æ®</small>
            `;
        }

        // å®šæ—¶æ›´æ–°å†…å­˜ä¿¡æ¯
        setInterval(updateMemoryInfo, 2000);
        updateMemoryInfo();
    </script>
</body>
</html>
